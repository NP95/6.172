Writeup 2
argv is a pointer to a char array. 
d would print 6 because it is a pointer to the first element in c. 
pcp = argv is valid because pcp is a pointer to a pointer to a char and argv is a pointer to the first element of a char array.
pcc2 is a pointer to a constant char.
*pcc = ‘7’ is invalid because you are trying to reassign the value of the char that’s constant.
pcc = *pcp is valid because pcc is a char and *pcp is a pointer to a char.
pcc = argv[0] is valid because both pcc and argv[0] is a char.
cp = *pcp is invalid because cp is a constant pointer so trying to reassign the pointer to another pointer won’t work.
cp = *argv is invalid because cp is still constant and we can’t modify cp to be another pointer.
*cp = ‘!’ is valid because *cp is just reassigning the value of the pointer to ‘!’.
cpc = *pcp is invalid because you can’t assign a constant pointer to a new pointer value.
cpc = argv[0] is invalid because you can’t assign a constant pointer to a char.
*cpc = ‘@‘ is invalid because the char that cpc points to is also constant so you can’t reassign it to a new char.

Writeup 3
size of int : 4 bytes
size of int* : 8 bytes
size of short : 2 bytes
size of short* : 8 bytes
size of long : 8 bytes
size of long* : 8 bytes
size of char : 1 bytes
size of char* : 8 bytes
size of float : 4 bytes
size of float* : 8 bytes
size of double : 8 bytes
size of double* : 8 bytes
size of unsigned int : 4 bytes
size of unsigned int* : 8 bytes
size of long long : 8 bytes
size of long long* : 8 bytes
size of uint8_t : 1 bytes
size of uint8_t* : 8 bytes
size of uint16_t : 2 bytes
size of uint16_t* : 8 bytes
size of uint32_t : 4 bytes
size of uint32_t* : 8 bytes
size of uint64_t : 8 bytes
size of uint64_t* : 8 bytes
size of uint_fast8_t : 1 bytes
size of uint_fast8_t* : 8 bytes
size of uint_fast16_t : 8 bytes
size of uint_fast16_t* : 8 bytes
size of uintmax_t : 8 bytes
size of uintmax_t* : 8 bytes
size of intmax_t : 8 bytes
size of intmax_t* : 8 bytes
size of __int128 : 16 bytes
size of __int128* : 8 bytes
size of x : 20 bytes
size of &x : 8 bytes
size of student : 8 bytes
size of &student : 8 bytes

Writeup 4
// Copyright (c) 2012 MIT License by 6.172 Staff

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

void swap(int * i, int * j) {
  int temp = *i;
  *i = *j;
  *j = temp;
}

int main() {
  int k = 1;
  int m = 2;
  swap(&k, &m);
  // What does this print?
  printf("k = %d, m = %d\n", k, m);

  return 0;
}

Writeup 5
rm -f testbed.o matrix_multiply.o matrix_multiply .buildmode \
        testbed.gcda matrix_multiply.gcda \
        testbed.gcno matrix_multiply.gcno \
        testbed.c.gcov matrix_multiply.c.gcov fasttime.h.gcov
clang -O3 -DNDEBUG -Wall -std=c99 -D_POSIX_C_SOURCE=200809L   -c -o testbed.o testbed.c
clang -O3 -DNDEBUG -Wall -std=c99 -D_POSIX_C_SOURCE=200809L   -c -o matrix_multiply.o matrix_multiply.c
clang -o matrix_multiply testbed.o matrix_multiply.o -lrt -flto -fuse-ld=gold

Writeup 6
==14369==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)
==14369==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you're using ulimit -v
This output indicates that we have memory overflow due to the large numbers.

Writeup 7
---- RESULTS ----
Result:
------------
47     55    122    130
79     83    138    164
74     40     75    114
130     95     74    144
------------
---- END RESULTS ----

Writeup 8
==20785== Memcheck, a memory error detector
==20785== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==20785== Using Valgrind-3.10.1 and LibVEX; rerun with -h for copyright info
==20785== Command: ./matrix_multiply -p
==20785==
Setup
Matrix A:
------------
3      7      8      1
7      9      8      3
1      2      6      7
9      8      1      9
------------
Matrix B:
------------
1      3      0      1
5      5      7      8
0      1      9      8
9      3      1      7
------------
Running matrix_multiply_run()...
---- RESULTS ----
Result:
------------
47     55    122    130
79     83    138    164
74     40     75    114
130     95     74    144
------------
---- END RESULTS ----
Elapsed execution time: 0.002341 sec
==20785==
==20785== HEAP SUMMARY:
==20785==     in use at exit: 0 bytes in 0 blocks
==20785==   total heap usage: 38 allocs, 38 frees, 656 bytes allocated
==20785==
==20785== All heap blocks were freed -- no leaks are possible
==20785==
==20785== For counts of detected and suppressed errors, rerun with: -v
==20785== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)

Writeup 9
Before optimization: Elapsed execution time: 1.445083 sec
After optimization: Elapsed execution time: 0.861820 sec

Writeup 10
Debug Mode with -00: Elapsed execution time: 4.116117 sec
Nondebug Mode with -03: Elapsed execution time: 0.861820 sec

